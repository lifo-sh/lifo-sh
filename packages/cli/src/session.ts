/**
 * session.ts — VM session registry
 *
 * Each running lifo VM (daemon process) is tracked by a pair of files stored
 * on the host filesystem under ~/.lifo/sessions/:
 *
 *   <id>.json  — metadata: pid, socket path, mount path, start time
 *   <id>.sock  — Unix domain socket the daemon listens on (created by the daemon)
 *
 * This module provides helpers to read, write, list, and delete those records.
 * It is used by both the CLI (to display / stop VMs) and the daemon itself
 * (to register itself on startup and clean up on shutdown).
 */

import * as fs from 'node:fs';
import * as os from 'node:os';
import * as path from 'node:path';

/** Metadata persisted to disk for every running VM. */
export interface Session {
  /** Short hex ID, e.g. "a1b2c3". Generated by startDaemon(). */
  id: string;
  /** OS PID of the daemon Node.js process. Used to check liveness and send signals. */
  pid: number;
  /** Absolute path to the Unix socket the daemon listens on. */
  socketPath: string;
  /** Absolute path on the host filesystem that is mounted at /mnt/host inside the VM. */
  mountPath: string;
  /** ISO-8601 timestamp of when the daemon started. */
  startedAt: string;
  /**
   * TCP port the daemon is also listening on (when started with --port).
   * Undefined for Unix-socket-only daemons. Allows remote attach via TCP.
   * WARNING: TCP attach is unauthenticated — anyone who can reach this port
   * can attach to the VM. Suitable for local/trusted-network use only.
   */
  port?: number;
}

/** Root directory for all session files on the host. Created on demand. */
export const SESSIONS_DIR = path.join(os.homedir(), '.lifo', 'sessions');

function ensureSessionsDir(): void {
  fs.mkdirSync(SESSIONS_DIR, { recursive: true });
}

/**
 * Persists a session record to ~/.lifo/sessions/<id>.json.
 * Called by the daemon right after its socket server starts listening.
 */
export function writeSession(session: Session): void {
  ensureSessionsDir();
  fs.writeFileSync(
    path.join(SESSIONS_DIR, `${session.id}.json`),
    JSON.stringify(session, null, 2),
  );
}

/**
 * Removes the session JSON, socket, and startup log files for a given ID.
 * Called on daemon shutdown (SIGTERM/SIGHUP) and by `lifo stop`.
 * All unlinks are best-effort — missing files are silently ignored.
 */
export function deleteSession(id: string): void {
  try { fs.unlinkSync(path.join(SESSIONS_DIR, `${id}.json`)); } catch { /* already gone */ }
  try { fs.unlinkSync(path.join(SESSIONS_DIR, `${id}.sock`)); } catch { /* already gone */ }
  try { fs.unlinkSync(path.join(SESSIONS_DIR, `${id}.log`)); } catch { /* already gone */ }
}

/**
 * Validates that a parsed JSON object has the required Session fields with
 * correct types. Guards against corrupted session files crashing callers that
 * use session.pid for process.kill() or session.socketPath for connect().
 */
function isValidSession(obj: unknown): obj is Session {
  if (typeof obj !== 'object' || obj === null) return false;
  const s = obj as Record<string, unknown>;
  return (
    typeof s.id === 'string' &&
    typeof s.pid === 'number' &&
    typeof s.socketPath === 'string' &&
    typeof s.mountPath === 'string' &&
    typeof s.startedAt === 'string' &&
    (s.port === undefined || typeof s.port === 'number')
  );
}

/**
 * Reads a single session record by ID.
 * Returns null if the file doesn't exist, is malformed, or has wrong field types.
 */
export function readSession(id: string): Session | null {
  try {
    const raw = fs.readFileSync(path.join(SESSIONS_DIR, `${id}.json`), 'utf-8');
    const parsed = JSON.parse(raw);
    return isValidSession(parsed) ? parsed : null;
  } catch {
    return null;
  }
}

/**
 * Checks whether a process with the given PID is currently alive.
 * Uses signal 0 which tests existence without sending a real signal.
 */
function isPidAlive(pid: number): boolean {
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}

/**
 * Returns all sessions found in ~/.lifo/sessions/, each annotated with an
 * `alive` flag indicating whether the daemon process is still running.
 *
 * Dead sessions (stale JSON files left from a crashed daemon) are included
 * in the list so the user can see and clean them up with `lifo stop`.
 */
export function listSessions(): Array<Session & { alive: boolean }> {
  ensureSessionsDir();
  const files = fs.readdirSync(SESSIONS_DIR).filter(f => f.endsWith('.json'));
  const sessions: Array<Session & { alive: boolean }> = [];
  for (const file of files) {
    try {
      const raw = fs.readFileSync(path.join(SESSIONS_DIR, file), 'utf-8');
      const parsed = JSON.parse(raw);
      if (!isValidSession(parsed)) continue;
      const alive = isPidAlive(parsed.pid);
      // Clean up the orphaned socket file for dead sessions so stale .sock
      // files don't accumulate (the .json is kept so the user can see dead VMs
      // via `lifo list` and clean them up with `lifo stop`).
      if (!alive) {
        try { fs.unlinkSync(path.join(SESSIONS_DIR, `${parsed.id}.sock`)); } catch { /* already gone */ }
      }
      sessions.push({ ...parsed, alive });
    } catch {
      // Skip malformed or unreadable session files.
    }
  }
  return sessions;
}
